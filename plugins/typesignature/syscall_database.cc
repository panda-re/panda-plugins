// WARNING: Autogenerated code
#include <algorithm>
#include <cstring>
#include <map>
#include <sqlite3.h>
#include <string>
#include <unordered_map>
#include <vector>

#include "panda/plugin.h"
#include "arguments.h"
#include "find_syscall_database.h"
#include "syscall_database.h"
#include "tuple_hash.h"

namespace SyscallDatabase
{

// TODO Replace with a better representation of types
std::vector<std::string> type_vector;
std::map<std::string, SyscallID> sid_lookup_table;
std::map<SyscallID, std::string> name_lookup_table;
std::map<SyscallID, std::vector<const ArgSpec*>*> arg_map;
std::unordered_map<std::tuple<uint64_t, uint64_t, uint64_t>, int> unique_call_id_map;
static std::vector<const ArgSpec*> UNKNOWN_DEFAULT_ARGVECTOR = {};

static std::string PROFILE_QUERY = "SELECT * from syscall_profile where profile = ?;";
int64_t fetch_profile_name(sqlite3* db, const char* profile_name)
{
    sqlite3_stmt* stmt;
    int64_t returnval = -1;
    auto status = sqlite3_prepare_v2(db, PROFILE_QUERY.c_str(), -1, &stmt, nullptr);
    if (status != SQLITE_OK) {
        return returnval;
    }
    status = sqlite3_bind_text(stmt, 1, profile_name, -1, nullptr);
    if (status != SQLITE_OK) {
        return returnval;
    }
    status = sqlite3_step(stmt);
    if (status != SQLITE_DONE) {
        returnval = sqlite3_column_int64(stmt, 0);
    }

    sqlite3_finalize(stmt);
    return returnval;
}

bool lookup_syscall_id_by_name(const char* syscall_name, SyscallID& sid)
{
    std::string syscall_name_str(syscall_name);
    auto candidate = sid_lookup_table.find(syscall_name_str);
    if (candidate == sid_lookup_table.end()) {
        // Don't have a syscall for this string
        // Get new ID for string
        SyscallID new_id = name_lookup_table.rbegin()->first + 1;
        std::string new_name = std::string(syscall_name);
        sid_lookup_table.insert(std::make_pair(new_name, new_id));
        name_lookup_table.insert(std::make_pair(new_id, new_name));

        arg_map.insert(std::make_pair(new_id, &UNKNOWN_DEFAULT_ARGVECTOR));

        sid = new_id;
        return false;
    }

    sid = candidate->second;
    return true;
}

bool lookup_syscall_name_by_id(char const** syscall_name, SyscallID sid)
{
    auto candidate = name_lookup_table.find(sid);
    if (candidate == name_lookup_table.end()) {
        // Don't have a syscall for this string
        if (syscall_name) {
            *syscall_name = nullptr;
        }
        return false;
    }

    // be extra paranoid
    // if (candidate->second.size() && syscall_name) {
    if (syscall_name) {
        *syscall_name = candidate->second.c_str();
    }
    return true;
}

// Lookup the number of arguments for a given syscall
int lookup_syscall_argument_count(SyscallID sid)
{
    auto candidate = arg_map.find(sid);
    if (candidate == arg_map.end()) {
        return -1;
    }

    auto arg_vector = candidate->second;
    if (arg_vector == nullptr) {
        return -1;
    }

    return arg_vector->size();
}

// Return an argument specification or nullptr
const ArgSpec* lookup_syscall_argument_specification(SyscallID sid, int pos)
{
    auto candidate = arg_map.find(sid);
    if (candidate == arg_map.end()) {
        return nullptr;
    }

    auto arg_vector = candidate->second;
    if (arg_vector == nullptr || pos < 0 || (size_t)pos > arg_vector->size()) {
        return nullptr;
    }

    return (*arg_vector)[pos];
}

void register_types(void (*register_type_cb)(const char*))
{
    for (const auto& tname : type_vector) {
        register_type_cb(tname.c_str());
    }
}

void register_syscalls(void (*register_syscall_cb)(int64_t, const char*, int))
{
    // std::map<SyscallID, std::vector<const ArgSpec*>*> arg_map;
    // for (auto pair : arg_map) {
    for (auto& pair : name_lookup_table) {
        const char* syscall_name = nullptr;
        auto syscall_id = pair.first;
        lookup_syscall_name_by_id(&syscall_name, syscall_id);
        auto narg = lookup_syscall_argument_count(syscall_id);
        register_syscall_cb(syscall_id, syscall_name, narg);
    }
}

void register_syscall_arguments(
    void (*register_syscall_arguments_cb)(int64_t, const ArgSpec* const*, int))
{
    for (auto pair : arg_map) {
        auto syscall_id = pair.first;
        const auto& arg_list = pair.second;
        register_syscall_arguments_cb(syscall_id, arg_list->data(), arg_list->size());
    }
}

static std::string SID_QUERY =
    "SELECT name, sid from syscall_sid where profile = ? order by sid;";
bool populate_translate(sqlite3* db, int64_t profile_id)
{
    sqlite3_stmt* stmt;
    auto status = sqlite3_prepare_v2(db, SID_QUERY.c_str(), -1, &stmt, nullptr);
    if (status != SQLITE_OK) {
        fprintf(stderr, "[E] Failed to prepare statement: %s\n", sqlite3_errmsg(db));
        return false;
    }
    status = sqlite3_bind_int(stmt, 1, profile_id);
    if (status != SQLITE_OK) {
        fprintf(stderr, "[E] Failed to bind statement: %s\n", sqlite3_errmsg(db));
        return false;
    }
    while (sqlite3_step(stmt) != SQLITE_DONE) {
        std::string name(reinterpret_cast<const char*>(sqlite3_column_text(stmt, 0)));
        int64_t sid = (int64_t)(sqlite3_column_int64(stmt, 1));
        sid_lookup_table[name] = sid;
        name_lookup_table[sid] = name;
    }
    sqlite3_finalize(stmt);
    return true;
}

static std::string TYPE_QUERY = "SELECT name from syscall_type where profile = ?;";
bool populate_type_vector(sqlite3* db, int64_t profile_id)
{
    sqlite3_stmt* stmt;
    auto status = sqlite3_prepare_v2(db, TYPE_QUERY.c_str(), -1, &stmt, nullptr);
    if (status != SQLITE_OK) {
        fprintf(stderr, "[E] Failed to prepare statement: %s\n", sqlite3_errmsg(db));
        return false;
    }
    status = sqlite3_bind_int(stmt, 1, profile_id);
    if (status != SQLITE_OK) {
        fprintf(stderr, "[E] Failed to bind statement: %s\n", sqlite3_errmsg(db));
        return false;
    }
    while (sqlite3_step(stmt) != SQLITE_DONE) {
        std::string name(reinterpret_cast<const char*>(sqlite3_column_text(stmt, 0)));
        type_vector.push_back(std::string(name));
    }
    sqlite3_finalize(stmt);
    return true;
}

static std::string ARGMAP_QUERY =
    "SELECT sid, position, io_type, arg_type, type_arg_position, length_in_arg_position, "
    "length_out_arg_position, name from syscall_arg where profile = ? order by sid, "
    "position;";
bool populate_arg_map(sqlite3* db, int64_t profile_id)
{
    sqlite3_stmt* stmt;
    auto status = sqlite3_prepare_v2(db, ARGMAP_QUERY.c_str(), -1, &stmt, nullptr);
    if (status != SQLITE_OK) {
        fprintf(stderr, "[E] Failed to prepare statement: %s\n", sqlite3_errmsg(db));
        return false;
    }
    status = sqlite3_bind_int(stmt, 1, profile_id);
    if (status != SQLITE_OK) {
        fprintf(stderr, "[E] Failed to bind statement: %s\n", sqlite3_errmsg(db));
        return false;
    }
    while (sqlite3_step(stmt) != SQLITE_DONE) {
        int64_t sid = sqlite3_column_int64(stmt, 0);
        int64_t position = sqlite3_column_int64(stmt, 1);
        int64_t io_type = sqlite3_column_int64(stmt, 2);
        auto arg_type = strdup((char*)sqlite3_column_text(stmt, 3));
        int64_t type_arg_position = sqlite3_column_int64(stmt, 4);
        int64_t length_in_arg_position = sqlite3_column_int64(stmt, 5);
        int64_t length_out_arg_position = sqlite3_column_int64(stmt, 6);
        auto name = std::string((char*)sqlite3_column_text(stmt, 7));

        auto candidate = arg_map.find(sid);
        if (candidate == arg_map.end()) {
            arg_map[sid] = new std::vector<const ArgSpec*>;
        }

        auto aspec =
            new ArgSpec(position, (ArgIoType)io_type, arg_type, type_arg_position,
                        length_in_arg_position, length_out_arg_position, name);
        arg_map[sid]->push_back(aspec);

        // pass
    }
    sqlite3_finalize(stmt);
    return true;
}

static std::string CALLUNIQUE_QUERY = "SELECT profile, rva, timestamp, imagesize, "
                                      "call_id from call_unique where profile = ?;";
bool populate_call_unique(sqlite3* db, int64_t profile_id)
{
    sqlite3_stmt* stmt;
    auto status = sqlite3_prepare_v2(db, CALLUNIQUE_QUERY.c_str(), -1, &stmt, nullptr);
    if (status != SQLITE_OK) {
        fprintf(stderr, "[E] Failed to prepare statement: %s\n", sqlite3_errmsg(db));
        return false;
    }
    status = sqlite3_bind_int(stmt, 1, profile_id);
    if (status != SQLITE_OK) {
        fprintf(stderr, "[E] Failed to bind statement: %s\n", sqlite3_errmsg(db));
        return false;
    }

    while (sqlite3_step(stmt) != SQLITE_DONE) {
        uint64_t rva = static_cast<uint64_t>(sqlite3_column_int64(stmt, 1));
        uint64_t timestamp = static_cast<uint64_t>(sqlite3_column_int64(stmt, 2));
        uint64_t imagesize = static_cast<uint64_t>(sqlite3_column_int64(stmt, 3));
        uint64_t call_id = static_cast<uint64_t>(sqlite3_column_int64(stmt, 4));

        std::tuple<uint64_t, uint64_t, uint64_t> tup =
            std::make_tuple(rva, timestamp, imagesize);
        unique_call_id_map[tup] = call_id;
    }
    sqlite3_finalize(stmt);
    return true;
}

bool load_syscall_data(const char* profile, const char* database)
{
    std::string s_os;
    switch (panda_os_familyno) {
    case OS_WINDOWS:
        s_os = "windows_";
        break;
    case OS_LINUX:
        s_os = "linux_";
        break;
    default:
        return false;
    }

    std::string database_name = s_os + std::string(database);

    std::string dbpath = find_syscall_database(database_name);
    sqlite3* db;
    int status = sqlite3_open(dbpath.c_str(), &db);
    if (status != SQLITE_OK) {
        fprintf(stderr, "[E] Failed to load syscall database (%d): %s\n", status,
                sqlite3_errmsg(db));
        return false;
    }

    int64_t profile_id;
    if ((profile_id = fetch_profile_name(db, profile)) < 0) {
        fprintf(stderr, "[%s] Could not find syscall database for profile: %s\n",
                __FILE__, profile);
        return false;
    }

    if (!populate_translate(db, profile_id)) {
        fprintf(stderr, "[%s] Could not populate translate: %s\n", __FILE__, profile);
        return false;
    }

    if (!populate_type_vector(db, profile_id)) {
        fprintf(stderr, "[%s] Could not populate type vector: %s\n", __FILE__, profile);
        return false;
    }

    if (!populate_arg_map(db, profile_id)) {
        fprintf(stderr, "[%s] Could not populate type vector: %s\n", __FILE__, profile);
        return false;
    }

    if (!populate_call_unique(db, profile_id)) {
        fprintf(stderr, "[%s] Could not populate call unique vector: %s\n", __FILE__,
                profile);
        return false;
    }

    sqlite3_close(db);
    return true;
}

// Return true if the call id was found
bool lookup_call_id_by_export_info(uint64_t rva, uint64_t timestamp, uint64_t imagesize,
                                   int& cid)
{
    auto candidate = unique_call_id_map.find(std::make_tuple(rva, timestamp, imagesize));
    if (candidate == unique_call_id_map.end()) {
        return false;
    } else {
        cid = candidate->second;
        return true;
    }
}

} // namespace SyscallDatabase
